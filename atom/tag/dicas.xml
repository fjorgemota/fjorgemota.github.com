<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Fernando Jorge Mota</title><link href="http://fjorgemota.com/" rel="alternate"></link><link href="http://fjorgemota.com/atom/tag/dicas.xml" rel="self"></link><id>http://fjorgemota.com/</id><updated>2013-06-05T21:24:09-03:00</updated><entry><title>O que é AMD? (JavaScript)</title><link href="http://fjorgemota.com/artigo/o-que-e-amd-javascript/" rel="alternate"></link><updated>2013-06-05T21:24:09-03:00</updated><author><name>Fernando Jorge Mota</name></author><id>tag:fjorgemota.com,2013-06-05:artigo/o-que-e-amd-javascript/</id><summary type="html">&lt;p&gt;Quando você vai implementar um grande web app, é comum possuir uma &lt;strong&gt;grande&lt;/strong&gt; quantidade de arquivos JavaScript. Naturalmente (à menos que você seja louco em botar tudo em um só arquivo), os arquivos estabelecem &lt;strong&gt;grande&lt;/strong&gt; relação de dependência entre si, sendo necessário que seja estabelecido, em algum lugar, o carregamento dos módulos na ordem correta. E, dependendo do tamanho da aplicação, isso pode ficar &lt;strong&gt;muito&lt;/strong&gt; trabalhoso e ocasionar muitos problemas, e é por causa disso que hoje vamos responder a seguinte pergunta: &lt;strong&gt;O que é AMD?&lt;/strong&gt; E dica: Não estamos falando sobre a fabricante de processadores.&lt;/p&gt;
&lt;p&gt;AMD é um jeito de definir módulos em JavaScript. Por módulos, entenda arquivos que devem realizar apenas uma função ou grupo de funções do mesmo gênero (pois compartilham um mesmo &lt;strong&gt;escopo&lt;/strong&gt;). &lt;/p&gt;
&lt;p&gt;Considere, por exemplo, que temos um arquivo chamado &lt;code&gt;hello.js&lt;/code&gt; com esta única função:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Hello, &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Guest&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Usando AMD, o arquivo ficaria assim:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
    &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
        &lt;span class="nx"&gt;alert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Hello, &amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Guest&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note que a primeira vantagem que o uso de AMD em seus arquivos é o escopo: Os arquivos não tem acesso inicial ao escopo global, ficando emglobados dentro de uma mesma função, assim como imposto pelos &lt;strong&gt;controllers&lt;/strong&gt; do &lt;a href="http://fjorgemota.com/artigo/angularjs-aplicativos-estruturados-com-facilidade/"&gt;Angular.js&lt;/a&gt;, do qual falamos ontem.&lt;/p&gt;
&lt;p&gt;Além disso, digamos que nós temos um arquivo chamado &lt;code&gt;foo.js&lt;/code&gt; que &lt;strong&gt;precisa&lt;/strong&gt; da função &lt;code&gt;hello&lt;/code&gt;. Sem AMD, o arquivo chamaria a função assim:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;userName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;prompt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;What&amp;#39;s your name?&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;userName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;em&gt;Hmmm&lt;/em&gt;..Meio confuso, né? E se a função simplesmente não existir ou não tiver sido carregada ainda?&lt;/p&gt;
&lt;p&gt;Com AMD, a história é diferente:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;define&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;userName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;prompt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;What&amp;#39;s your name?&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nx"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;userName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Note que no código acima, o arquivo &lt;strong&gt;especifica&lt;/strong&gt; como requerimento o &lt;strong&gt;módulo&lt;/strong&gt; &lt;code&gt;hello.js&lt;/code&gt; (a extensão &lt;code&gt;.js&lt;/code&gt; é sub-entendida no AMD), e recebe como parâmetro justamente o resultado retornado pelo módulo. Isso possibilita uma &lt;strong&gt;enorme&lt;/strong&gt; quantidade de possibilidades:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Carregamento de módulos recursivos&lt;/strong&gt; - Se o módulo &lt;code&gt;hello&lt;/code&gt; possuisse alguma outra dependência, seria possível ao carregador AMD &lt;strong&gt;carregar&lt;/strong&gt; tais dependências &lt;strong&gt;sem&lt;/strong&gt; executar a função e &lt;strong&gt;sem&lt;/strong&gt; provocar exceptions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Otimização&lt;/strong&gt; - Se um módulo não é carregado, porque vamos utilizá-lo?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Dependency Injection&lt;/strong&gt; - Pois na maioria das bibliotecas (como na Require.js, abordada neste artigo) você pode definir alias para os módulos com facilidade.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Qualidade de código&lt;/strong&gt; - As dependências ficam &lt;strong&gt;totalmente&lt;/strong&gt; explicitas.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Legal mas..como usar AMD? Simples! Use uma biblioteca que implemente a API, e seja feliz! Pessoalmente, eu indico MUITO a &lt;a href="http://fjorgemota.com/artigo/requirejs-carregando-scripts-na-hora-certa/"&gt;Require.js&lt;/a&gt;, mas você é livre para escolher a que lhe parecer mais interessante.&lt;/p&gt;
&lt;p&gt;Aliás, falando em bibliotecas, veja algumas bibliotecas que &lt;strong&gt;já&lt;/strong&gt; suportam nativamente AMD:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jQuery &lt;/li&gt;
&lt;li&gt;Dojo&lt;/li&gt;
&lt;li&gt;E a maior parte das mais recentes bibliotecas JavaScript publicadas na internet.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bom, é isso! Dúvidas? Deixe nos comentários! &lt;/p&gt;</summary><category term="JavaScript"></category><category term="Dicas"></category></entry></feed>